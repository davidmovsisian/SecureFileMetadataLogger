using System;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;

public class ServiceProvider
{
    private static readonly Dictionary<Type, object> _services = new();
    private static readonly Dictionary<Type, Type> _registrations = new();

    public void AddService<IService, Service>() where Service : IService
    {
        var interfaceType = typeof(IService);
        var implementationType = typeof(Service);

        if (_registrations.ContainsKey(interfaceType))
        {
            throw new InvalidOperationException($"Service {interfaceType.Name} is already registered.");
        }

        _registrations[interfaceType] = implementationType;
    }

    public static IService GetService<IService>()
    {
        return (IService)GetService(typeof(IService));
    }

    private static object GetService(Type serviceType)
    {
        // Return existing instance if already created
        if (_services.TryGetValue(serviceType, out var existingInstance))
        {
            return existingInstance;
        }

        // Check if the service was registered
        if (!_registrations.TryGetValue(serviceType, out var implementationType))
        {
            throw new InvalidOperationException($"Service {serviceType.Name} is not registered.");
        }

        // Get constructor and resolve dependencies
        var constructor = implementationType
            .GetConstructors()
            .OrderByDescending(c => c.GetParameters().Length) // Prefer most params
            .FirstOrDefault();

        if (constructor == null)
        {
            throw new InvalidOperationException($"No public constructor found for {implementationType.Name}.");
        }

        var parameters = constructor.GetParameters()
            .Select(p => GetService(p.ParameterType))
            .ToArray();

        var instance = constructor.Invoke(parameters);
        _services[serviceType] = instance;

        return instance;
    }
}

//----------
public IEnumerable<TSource> DistinctBy<TSource, TKey>(this IEnumerable<TSource> source, Func<TSource, TKey> selector)
{
	if(source == null)
		throw new ArgumentNullException("source is missing");
	if(selector == null)
		throw new ArgumentNullException("selector is missing");
	
	HashSet<TKey> set = new HashSet<TKey>();
	
	foreach(var item in source)
	{
		if(set.Add(selector(item))
			yield item;
	}
}

var list = new List<Person>{
	new Person{
		Id =1,
		Name ="dd"
	},
	new Person{
		Id =2,
		Name ="dd"
	}
}

var filtered = list.DistinctBy(p => p.Name);//return only first Person

public IEnumerable<TSource> Except<TSource>(this IEnumerable<TSource> first, IEnumerable<TSource> second, IEqualityComparer<Tsource> comparer = null)
{
	if(first == null || second == nuint)
		throw ArgumentNullException("missing input");
	
	var set = new HashSet<Tsource>(second, comparer);
	foreach(var item in first)
	{
		if(!set.Contains(item))
			yield item;
	}
}


that, given an array A of N integers, returns the smallest positive integer (greater than 0) that does not occur in A.

For example, given A = [1, 3, 6, 4, 1, 2], the function should return 5.

Given A = [1, 2, 3], the function should return 4.

Given A = [−1, −3], the function should return 1.

Write an efficient algorithm for the following assumptions:

N is an integer within the range [1..100,000];
each element of array A is an integer within the range [−1,000,000..1,000,000].

using System;
using System.Collections.Generic;
// you can also use other imports, for example:
// using System.Collections.Generic;

// you can write to stdout for debugging purposes, e.g.
// Console.WriteLine("this is a debug message");

class Solution {
    public int solution(int[] A) {

        if(A.Length == 1)
            return Math.Abs(A[0]) + 1;

        var setA = new HashSet<int>(A);
        
        //find max pos element
        var maxPos =-1000000;

        for(int i=1 ; i< setA.Count; i++)
        {
            if(setA[i] > maxPos)
                maxPos = set[i];
        }

        //itterate over array
        for(int i =1; i<setA.Count; i++ )
        {
            if(setA[i] - setA[i -1] > 1 )
                return setA[i] + 1;
        }


        return setA[setA.Count -1] +1;
    }
}
using System;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;

public class ServiceProvider
{
    private static readonly Dictionary<Type, object> _services = new();
    private static readonly Dictionary<Type, Type> _registrations = new();

    public void AddService<IService, Service>() where Service : IService
    {
        var interfaceType = typeof(IService);
        var implementationType = typeof(Service);

        if (_registrations.ContainsKey(interfaceType))
        {
            throw new InvalidOperationException($"Service {interfaceType.Name} is already registered.");
        }

        _registrations[interfaceType] = implementationType;
    }

    public static IService GetService<IService>()
    {
        return (IService)GetService(typeof(IService));
    }

    private static object GetService(Type serviceType)
    {
        // Return existing instance if already created
        if (_services.TryGetValue(serviceType, out var existingInstance))
        {
            return existingInstance;
        }

        // Check if the service was registered
        if (!_registrations.TryGetValue(serviceType, out var implementationType))
        {
            throw new InvalidOperationException($"Service {serviceType.Name} is not registered.");
        }

        // Get constructor and resolve dependencies
        var constructor = implementationType
            .GetConstructors()
            .OrderByDescending(c => c.GetParameters().Length) // Prefer most params
            .FirstOrDefault();

        if (constructor == null)
        {
            throw new InvalidOperationException($"No public constructor found for {implementationType.Name}.");
        }

        var parameters = constructor.GetParameters()
            .Select(p => GetService(p.ParameterType))
            .ToArray();

        var instance = constructor.Invoke(parameters);
        _services[serviceType] = instance;

        return instance;
    }
}

//----------
public IEnumerable<TSource> DistinctBy<TSource, TKey>(this IEnumerable<TSource> source, Func<TSource, TKey> selector)
{
	if(source == null)
		throw new ArgumentNullException("source is missing");
	if(selector == null)
		throw new ArgumentNullException("selector is missing");
	
	HashSet<TKey> set = new HashSet<TKey>();
	
	foreach(var item in source)
	{
		if(set.Add(selector(item))
			yield item;
	}
}

var list = new List<Person>{
	new Person{
		Id =1,
		Name ="dd"
	},
	new Person{
		Id =2,
		Name ="dd"
	}
}

var filtered = list.DistinctBy(p => p.Name);//return only first Person

public IEnumerable<TSource> Except<TSource>(this IEnumerable<TSource> first, IEnumerable<TSource> second, IEqualityComparer<Tsource> comparer = null)
{
	if(first == null || second == nuint)
		throw ArgumentNullException("missing input");
	
	var set = new HashSet<Tsource>(second, comparer);
	foreach(var item in first)
	{
		if(!set.Contains(item))
			yield item;
	}
}


that, given an array A of N integers, returns the smallest positive integer (greater than 0) that does not occur in A.

For example, given A = [1, 3, 6, 4, 1, 2], the function should return 5.

Given A = [1, 2, 3], the function should return 4.

Given A = [−1, −3], the function should return 1.

Write an efficient algorithm for the following assumptions:

N is an integer within the range [1..100,000];
each element of array A is an integer within the range [−1,000,000..1,000,000].

using System;
using System.Collections.Generic;
// you can also use other imports, for example:
// using System.Collections.Generic;

// you can write to stdout for debugging purposes, e.g.
// Console.WriteLine("this is a debug message");

class Solution {
    public int solution(int[] A) {

        if(A.Length == 1)
            return Math.Abs(A[0]) + 1;

        var setA = new HashSet<int>(A);
        
        //find max pos element
        var maxPos =-1000000;

        for(int i=1 ; i< setA.Count; i++)
        {
            if(setA[i] > maxPos)
                maxPos = set[i];
        }

        //itterate over array
        for(int i =1; i<setA.Count; i++ )
        {
            if(setA[i] - setA[i -1] > 1 )
                return setA[i] + 1;
        }


        return setA[setA.Count -1] +1;
    }
}
using System;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;

public class ServiceProvider
{
    private static readonly Dictionary<Type, object> _services = new();
    private static readonly Dictionary<Type, Type> _registrations = new();

    public void AddService<IService, Service>() where Service : IService
    {
        var interfaceType = typeof(IService);
        var implementationType = typeof(Service);

        if (_registrations.ContainsKey(interfaceType))
        {
            throw new InvalidOperationException($"Service {interfaceType.Name} is already registered.");
        }

        _registrations[interfaceType] = implementationType;
    }

    public static IService GetService<IService>()
    {
        return (IService)GetService(typeof(IService));
    }

    private static object GetService(Type serviceType)
    {
        // Return existing instance if already created
        if (_services.TryGetValue(serviceType, out var existingInstance))
        {
            return existingInstance;
        }

        // Check if the service was registered
        if (!_registrations.TryGetValue(serviceType, out var implementationType))
        {
            throw new InvalidOperationException($"Service {serviceType.Name} is not registered.");
        }

        // Get constructor and resolve dependencies
        var constructor = implementationType
            .GetConstructors()
            .OrderByDescending(c => c.GetParameters().Length) // Prefer most params
            .FirstOrDefault();

        if (constructor == null)
        {
            throw new InvalidOperationException($"No public constructor found for {implementationType.Name}.");
        }

        var parameters = constructor.GetParameters()
            .Select(p => GetService(p.ParameterType))
            .ToArray();

        var instance = constructor.Invoke(parameters);
        _services[serviceType] = instance;

        return instance;
    }
}

//----------
public IEnumerable<TSource> DistinctBy<TSource, TKey>(this IEnumerable<TSource> source, Func<TSource, TKey> selector)
{
	if(source == null)
		throw new ArgumentNullException("source is missing");
	if(selector == null)
		throw new ArgumentNullException("selector is missing");
	
	HashSet<TKey> set = new HashSet<TKey>();
	
	foreach(var item in source)
	{
		if(set.Add(selector(item))
			yield item;
	}
}

var list = new List<Person>{
	new Person{
		Id =1,
		Name ="dd"
	},
	new Person{
		Id =2,
		Name ="dd"
	}
}

var filtered = list.DistinctBy(p => p.Name);//return only first Person

public IEnumerable<TSource> Except<TSource>(this IEnumerable<TSource> first, IEnumerable<TSource> second, IEqualityComparer<Tsource> comparer = null)
{
	if(first == null || second == nuint)
		throw ArgumentNullException("missing input");
	
	var set = new HashSet<Tsource>(second, comparer);
	foreach(var item in first)
	{
		if(!set.Contains(item))
			yield item;
	}
}


that, given an array A of N integers, returns the smallest positive integer (greater than 0) that does not occur in A.

For example, given A = [1, 3, 6, 4, 1, 2], the function should return 5.

Given A = [1, 2, 3], the function should return 4.

Given A = [−1, −3], the function should return 1.

Write an efficient algorithm for the following assumptions:

N is an integer within the range [1..100,000];
each element of array A is an integer within the range [−1,000,000..1,000,000].

using System;
using System.Collections.Generic;
// you can also use other imports, for example:
// using System.Collections.Generic;

// you can write to stdout for debugging purposes, e.g.
// Console.WriteLine("this is a debug message");

class Solution {
    public int solution(int[] A) {

        if(A.Length == 1)
            return Math.Abs(A[0]) + 1;

        var setA = new HashSet<int>(A);
        
        //find max pos element
        var maxPos =-1000000;

        for(int i=1 ; i< setA.Count; i++)
        {
            if(setA[i] > maxPos)
                maxPos = set[i];
        }

        //itterate over array
        for(int i =1; i<setA.Count; i++ )
        {
            if(setA[i] - setA[i -1] > 1 )
                return setA[i] + 1;
        }


        return setA[setA.Count -1] +1;
    }
}
using System;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;

public class ServiceProvider
{
    private static readonly Dictionary<Type, object> _services = new();
    private static readonly Dictionary<Type, Type> _registrations = new();

    public void AddService<IService, Service>() where Service : IService
    {
        var interfaceType = typeof(IService);
        var implementationType = typeof(Service);

        if (_registrations.ContainsKey(interfaceType))
        {
            throw new InvalidOperationException($"Service {interfaceType.Name} is already registered.");
        }

        _registrations[interfaceType] = implementationType;
    }

    public static IService GetService<IService>()
    {
        return (IService)GetService(typeof(IService));
    }

    private static object GetService(Type serviceType)
    {
        // Return existing instance if already created
        if (_services.TryGetValue(serviceType, out var existingInstance))
        {
            return existingInstance;
        }

        // Check if the service was registered
        if (!_registrations.TryGetValue(serviceType, out var implementationType))
        {
            throw new InvalidOperationException($"Service {serviceType.Name} is not registered.");
        }

        // Get constructor and resolve dependencies
        var constructor = implementationType
            .GetConstructors()
            .OrderByDescending(c => c.GetParameters().Length) // Prefer most params
            .FirstOrDefault();

        if (constructor == null)
        {
            throw new InvalidOperationException($"No public constructor found for {implementationType.Name}.");
        }

        var parameters = constructor.GetParameters()
            .Select(p => GetService(p.ParameterType))
            .ToArray();

        var instance = constructor.Invoke(parameters);
        _services[serviceType] = instance;

        return instance;
    }
}

//----------
public IEnumerable<TSource> DistinctBy<TSource, TKey>(this IEnumerable<TSource> source, Func<TSource, TKey> selector)
{
	if(source == null)
		throw new ArgumentNullException("source is missing");
	if(selector == null)
		throw new ArgumentNullException("selector is missing");
	
	HashSet<TKey> set = new HashSet<TKey>();
	
	foreach(var item in source)
	{
		if(set.Add(selector(item))
			yield item;
	}
}

var list = new List<Person>{
	new Person{
		Id =1,
		Name ="dd"
	},
	new Person{
		Id =2,
		Name ="dd"
	}
}

var filtered = list.DistinctBy(p => p.Name);//return only first Person

public IEnumerable<TSource> Except<TSource>(this IEnumerable<TSource> first, IEnumerable<TSource> second, IEqualityComparer<Tsource> comparer = null)
{
	if(first == null || second == nuint)
		throw ArgumentNullException("missing input");
	
	var set = new HashSet<Tsource>(second, comparer);
	foreach(var item in first)
	{
		if(!set.Contains(item))
			yield item;
	}
}


that, given an array A of N integers, returns the smallest positive integer (greater than 0) that does not occur in A.

For example, given A = [1, 3, 6, 4, 1, 2], the function should return 5.

Given A = [1, 2, 3], the function should return 4.

Given A = [−1, −3], the function should return 1.

Write an efficient algorithm for the following assumptions:

N is an integer within the range [1..100,000];
each element of array A is an integer within the range [−1,000,000..1,000,000].

using System;
using System.Collections.Generic;
// you can also use other imports, for example:
// using System.Collections.Generic;

// you can write to stdout for debugging purposes, e.g.
// Console.WriteLine("this is a debug message");

class Solution {
    public int solution(int[] A) {

        if(A.Length == 1)
            return Math.Abs(A[0]) + 1;

        var setA = new HashSet<int>(A);
        
        //find max pos element
        var maxPos =-1000000;

        for(int i=1 ; i< setA.Count; i++)
        {
            if(setA[i] > maxPos)
                maxPos = set[i];
        }

        //itterate over array
        for(int i =1; i<setA.Count; i++ )
        {
            if(setA[i] - setA[i -1] > 1 )
                return setA[i] + 1;
        }


        return setA[setA.Count -1] +1;
    }
}
using System;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;

public class ServiceProvider
{
    private static readonly Dictionary<Type, object> _services = new();
    private static readonly Dictionary<Type, Type> _registrations = new();

    public void AddService<IService, Service>() where Service : IService
    {
        var interfaceType = typeof(IService);
        var implementationType = typeof(Service);

        if (_registrations.ContainsKey(interfaceType))
        {
            throw new InvalidOperationException($"Service {interfaceType.Name} is already registered.");
        }

        _registrations[interfaceType] = implementationType;
    }

    public static IService GetService<IService>()
    {
        return (IService)GetService(typeof(IService));
    }

    private static object GetService(Type serviceType)
    {
        // Return existing instance if already created
        if (_services.TryGetValue(serviceType, out var existingInstance))
        {
            return existingInstance;
        }

        // Check if the service was registered
        if (!_registrations.TryGetValue(serviceType, out var implementationType))
        {
            throw new InvalidOperationException($"Service {serviceType.Name} is not registered.");
        }

        // Get constructor and resolve dependencies
        var constructor = implementationType
            .GetConstructors()
            .OrderByDescending(c => c.GetParameters().Length) // Prefer most params
            .FirstOrDefault();

        if (constructor == null)
        {
            throw new InvalidOperationException($"No public constructor found for {implementationType.Name}.");
        }

        var parameters = constructor.GetParameters()
            .Select(p => GetService(p.ParameterType))
            .ToArray();

        var instance = constructor.Invoke(parameters);
        _services[serviceType] = instance;

        return instance;
    }
}

//----------
public IEnumerable<TSource> DistinctBy<TSource, TKey>(this IEnumerable<TSource> source, Func<TSource, TKey> selector)
{
	if(source == null)
		throw new ArgumentNullException("source is missing");
	if(selector == null)
		throw new ArgumentNullException("selector is missing");
	
	HashSet<TKey> set = new HashSet<TKey>();
	
	foreach(var item in source)
	{
		if(set.Add(selector(item))
			yield item;
	}
}

var list = new List<Person>{
	new Person{
		Id =1,
		Name ="dd"
	},
	new Person{
		Id =2,
		Name ="dd"
	}
}

var filtered = list.DistinctBy(p => p.Name);//return only first Person

public IEnumerable<TSource> Except<TSource>(this IEnumerable<TSource> first, IEnumerable<TSource> second, IEqualityComparer<Tsource> comparer = null)
{
	if(first == null || second == nuint)
		throw ArgumentNullException("missing input");
	
	var set = new HashSet<Tsource>(second, comparer);
	foreach(var item in first)
	{
		if(!set.Contains(item))
			yield item;
	}
}


that, given an array A of N integers, returns the smallest positive integer (greater than 0) that does not occur in A.

For example, given A = [1, 3, 6, 4, 1, 2], the function should return 5.

Given A = [1, 2, 3], the function should return 4.

Given A = [−1, −3], the function should return 1.

Write an efficient algorithm for the following assumptions:

N is an integer within the range [1..100,000];
each element of array A is an integer within the range [−1,000,000..1,000,000].

using System;
using System.Collections.Generic;
// you can also use other imports, for example:
// using System.Collections.Generic;

// you can write to stdout for debugging purposes, e.g.
// Console.WriteLine("this is a debug message");

class Solution {
    public int solution(int[] A) {

        if(A.Length == 1)
            return Math.Abs(A[0]) + 1;

        var setA = new HashSet<int>(A);
        
        //find max pos element
        var maxPos =-1000000;

        for(int i=1 ; i< setA.Count; i++)
        {
            if(setA[i] > maxPos)
                maxPos = set[i];
        }

        //itterate over array
        for(int i =1; i<setA.Count; i++ )
        {
            if(setA[i] - setA[i -1] > 1 )
                return setA[i] + 1;
        }


        return setA[setA.Count -1] +1;
    }
}
using System;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;

public class ServiceProvider
{
    private static readonly Dictionary<Type, object> _services = new();
    private static readonly Dictionary<Type, Type> _registrations = new();

    public void AddService<IService, Service>() where Service : IService
    {
        var interfaceType = typeof(IService);
        var implementationType = typeof(Service);

        if (_registrations.ContainsKey(interfaceType))
        {
            throw new InvalidOperationException($"Service {interfaceType.Name} is already registered.");
        }

        _registrations[interfaceType] = implementationType;
    }

    public static IService GetService<IService>()
    {
        return (IService)GetService(typeof(IService));
    }

    private static object GetService(Type serviceType)
    {
        // Return existing instance if already created
        if (_services.TryGetValue(serviceType, out var existingInstance))
        {
            return existingInstance;
        }

        // Check if the service was registered
        if (!_registrations.TryGetValue(serviceType, out var implementationType))
        {
            throw new InvalidOperationException($"Service {serviceType.Name} is not registered.");
        }

        // Get constructor and resolve dependencies
        var constructor = implementationType
            .GetConstructors()
            .OrderByDescending(c => c.GetParameters().Length) // Prefer most params
            .FirstOrDefault();

        if (constructor == null)
        {
            throw new InvalidOperationException($"No public constructor found for {implementationType.Name}.");
        }

        var parameters = constructor.GetParameters()
            .Select(p => GetService(p.ParameterType))
            .ToArray();

        var instance = constructor.Invoke(parameters);
        _services[serviceType] = instance;

        return instance;
    }
}

//----------
public IEnumerable<TSource> DistinctBy<TSource, TKey>(this IEnumerable<TSource> source, Func<TSource, TKey> selector)
{
	if(source == null)
		throw new ArgumentNullException("source is missing");
	if(selector == null)
		throw new ArgumentNullException("selector is missing");
	
	HashSet<TKey> set = new HashSet<TKey>();
	
	foreach(var item in source)
	{
		if(set.Add(selector(item))
			yield item;
	}
}

var list = new List<Person>{
	new Person{
		Id =1,
		Name ="dd"
	},
	new Person{
		Id =2,
		Name ="dd"
	}
}

var filtered = list.DistinctBy(p => p.Name);//return only first Person

public IEnumerable<TSource> Except<TSource>(this IEnumerable<TSource> first, IEnumerable<TSource> second, IEqualityComparer<Tsource> comparer = null)
{
	if(first == null || second == nuint)
		throw ArgumentNullException("missing input");
	
	var set = new HashSet<Tsource>(second, comparer);
	foreach(var item in first)
	{
		if(!set.Contains(item))
			yield item;
	}
}


that, given an array A of N integers, returns the smallest positive integer (greater than 0) that does not occur in A.

For example, given A = [1, 3, 6, 4, 1, 2], the function should return 5.

Given A = [1, 2, 3], the function should return 4.

Given A = [−1, −3], the function should return 1.

Write an efficient algorithm for the following assumptions:

N is an integer within the range [1..100,000];
each element of array A is an integer within the range [−1,000,000..1,000,000].

using System;
using System.Collections.Generic;
// you can also use other imports, for example:
// using System.Collections.Generic;

// you can write to stdout for debugging purposes, e.g.
// Console.WriteLine("this is a debug message");

class Solution {
    public int solution(int[] A) {

        if(A.Length == 1)
            return Math.Abs(A[0]) + 1;

        var setA = new HashSet<int>(A);
        
        //find max pos element
        var maxPos =-1000000;

        for(int i=1 ; i< setA.Count; i++)
        {
            if(setA[i] > maxPos)
                maxPos = set[i];
        }

        //itterate over array
        for(int i =1; i<setA.Count; i++ )
        {
            if(setA[i] - setA[i -1] > 1 )
                return setA[i] + 1;
        }


        return setA[setA.Count -1] +1;
    }
}
using System;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;

public class ServiceProvider
{
    private static readonly Dictionary<Type, object> _services = new();
    private static readonly Dictionary<Type, Type> _registrations = new();

    public void AddService<IService, Service>() where Service : IService
    {
        var interfaceType = typeof(IService);
        var implementationType = typeof(Service);

        if (_registrations.ContainsKey(interfaceType))
        {
            throw new InvalidOperationException($"Service {interfaceType.Name} is already registered.");
        }

        _registrations[interfaceType] = implementationType;
    }

    public static IService GetService<IService>()
    {
        return (IService)GetService(typeof(IService));
    }

    private static object GetService(Type serviceType)
    {
        // Return existing instance if already created
        if (_services.TryGetValue(serviceType, out var existingInstance))
        {
            return existingInstance;
        }

        // Check if the service was registered
        if (!_registrations.TryGetValue(serviceType, out var implementationType))
        {
            throw new InvalidOperationException($"Service {serviceType.Name} is not registered.");
        }

        // Get constructor and resolve dependencies
        var constructor = implementationType
            .GetConstructors()
            .OrderByDescending(c => c.GetParameters().Length) // Prefer most params
            .FirstOrDefault();

        if (constructor == null)
        {
            throw new InvalidOperationException($"No public constructor found for {implementationType.Name}.");
        }

        var parameters = constructor.GetParameters()
            .Select(p => GetService(p.ParameterType))
            .ToArray();

        var instance = constructor.Invoke(parameters);
        _services[serviceType] = instance;

        return instance;
    }
}

//----------
public IEnumerable<TSource> DistinctBy<TSource, TKey>(this IEnumerable<TSource> source, Func<TSource, TKey> selector)
{
	if(source == null)
		throw new ArgumentNullException("source is missing");
	if(selector == null)
		throw new ArgumentNullException("selector is missing");
	
	HashSet<TKey> set = new HashSet<TKey>();
	
	foreach(var item in source)
	{
		if(set.Add(selector(item))
			yield item;
	}
}

var list = new List<Person>{
	new Person{
		Id =1,
		Name ="dd"
	},
	new Person{
		Id =2,
		Name ="dd"
	}
}

var filtered = list.DistinctBy(p => p.Name);//return only first Person

public IEnumerable<TSource> Except<TSource>(this IEnumerable<TSource> first, IEnumerable<TSource> second, IEqualityComparer<Tsource> comparer = null)
{
	if(first == null || second == nuint)
		throw ArgumentNullException("missing input");
	
	var set = new HashSet<Tsource>(second, comparer);
	foreach(var item in first)
	{
		if(!set.Contains(item))
			yield item;
	}
}


that, given an array A of N integers, returns the smallest positive integer (greater than 0) that does not occur in A.

For example, given A = [1, 3, 6, 4, 1, 2], the function should return 5.

Given A = [1, 2, 3], the function should return 4.

Given A = [−1, −3], the function should return 1.

Write an efficient algorithm for the following assumptions:

N is an integer within the range [1..100,000];
each element of array A is an integer within the range [−1,000,000..1,000,000].

using System;
using System.Collections.Generic;
// you can also use other imports, for example:
// using System.Collections.Generic;

// you can write to stdout for debugging purposes, e.g.
// Console.WriteLine("this is a debug message");

class Solution {
    public int solution(int[] A) {

        if(A.Length == 1)
            return Math.Abs(A[0]) + 1;

        var setA = new HashSet<int>(A);
        
        //find max pos element
        var maxPos =-1000000;

        for(int i=1 ; i< setA.Count; i++)
        {
            if(setA[i] > maxPos)
                maxPos = set[i];
        }

        //itterate over array
        for(int i =1; i<setA.Count; i++ )
        {
            if(setA[i] - setA[i -1] > 1 )
                return setA[i] + 1;
        }


        return setA[setA.Count -1] +1;
    }
}
using System;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;

public class ServiceProvider
{
    private static readonly Dictionary<Type, object> _services = new();
    private static readonly Dictionary<Type, Type> _registrations = new();

    public void AddService<IService, Service>() where Service : IService
    {
        var interfaceType = typeof(IService);
        var implementationType = typeof(Service);

        if (_registrations.ContainsKey(interfaceType))
        {
            throw new InvalidOperationException($"Service {interfaceType.Name} is already registered.");
        }

        _registrations[interfaceType] = implementationType;
    }

    public static IService GetService<IService>()
    {
        return (IService)GetService(typeof(IService));
    }

    private static object GetService(Type serviceType)
    {
        // Return existing instance if already created
        if (_services.TryGetValue(serviceType, out var existingInstance))
        {
            return existingInstance;
        }

        // Check if the service was registered
        if (!_registrations.TryGetValue(serviceType, out var implementationType))
        {
            throw new InvalidOperationException($"Service {serviceType.Name} is not registered.");
        }

        // Get constructor and resolve dependencies
        var constructor = implementationType
            .GetConstructors()
            .OrderByDescending(c => c.GetParameters().Length) // Prefer most params
            .FirstOrDefault();

        if (constructor == null)
        {
            throw new InvalidOperationException($"No public constructor found for {implementationType.Name}.");
        }

        var parameters = constructor.GetParameters()
            .Select(p => GetService(p.ParameterType))
            .ToArray();

        var instance = constructor.Invoke(parameters);
        _services[serviceType] = instance;

        return instance;
    }
}

//----------
public IEnumerable<TSource> DistinctBy<TSource, TKey>(this IEnumerable<TSource> source, Func<TSource, TKey> selector)
{
	if(source == null)
		throw new ArgumentNullException("source is missing");
	if(selector == null)
		throw new ArgumentNullException("selector is missing");
	
	HashSet<TKey> set = new HashSet<TKey>();
	
	foreach(var item in source)
	{
		if(set.Add(selector(item))
			yield item;
	}
}

var list = new List<Person>{
	new Person{
		Id =1,
		Name ="dd"
	},
	new Person{
		Id =2,
		Name ="dd"
	}
}

var filtered = list.DistinctBy(p => p.Name);//return only first Person

public IEnumerable<TSource> Except<TSource>(this IEnumerable<TSource> first, IEnumerable<TSource> second, IEqualityComparer<Tsource> comparer = null)
{
	if(first == null || second == nuint)
		throw ArgumentNullException("missing input");
	
	var set = new HashSet<Tsource>(second, comparer);
	foreach(var item in first)
	{
		if(!set.Contains(item))
			yield item;
	}
}


that, given an array A of N integers, returns the smallest positive integer (greater than 0) that does not occur in A.

For example, given A = [1, 3, 6, 4, 1, 2], the function should return 5.

Given A = [1, 2, 3], the function should return 4.

Given A = [−1, −3], the function should return 1.

Write an efficient algorithm for the following assumptions:

N is an integer within the range [1..100,000];
each element of array A is an integer within the range [−1,000,000..1,000,000].

using System;
using System.Collections.Generic;
// you can also use other imports, for example:
// using System.Collections.Generic;

// you can write to stdout for debugging purposes, e.g.
// Console.WriteLine("this is a debug message");

class Solution {
    public int solution(int[] A) {

        if(A.Length == 1)
            return Math.Abs(A[0]) + 1;

        var setA = new HashSet<int>(A);
        
        //find max pos element
        var maxPos =-1000000;

        for(int i=1 ; i< setA.Count; i++)
        {
            if(setA[i] > maxPos)
                maxPos = set[i];
        }

        //itterate over array
        for(int i =1; i<setA.Count; i++ )
        {
            if(setA[i] - setA[i -1] > 1 )
                return setA[i] + 1;
        }


        return setA[setA.Count -1] +1;
    }
}
using System;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;

public class ServiceProvider
{
    private static readonly Dictionary<Type, object> _services = new();
    private static readonly Dictionary<Type, Type> _registrations = new();

    public void AddService<IService, Service>() where Service : IService
    {
        var interfaceType = typeof(IService);
        var implementationType = typeof(Service);

        if (_registrations.ContainsKey(interfaceType))
        {
            throw new InvalidOperationException($"Service {interfaceType.Name} is already registered.");
        }

        _registrations[interfaceType] = implementationType;
    }

    public static IService GetService<IService>()
    {
        return (IService)GetService(typeof(IService));
    }

    private static object GetService(Type serviceType)
    {
        // Return existing instance if already created
        if (_services.TryGetValue(serviceType, out var existingInstance))
        {
            return existingInstance;
        }

        // Check if the service was registered
        if (!_registrations.TryGetValue(serviceType, out var implementationType))
        {
            throw new InvalidOperationException($"Service {serviceType.Name} is not registered.");
        }

        // Get constructor and resolve dependencies
        var constructor = implementationType
            .GetConstructors()
            .OrderByDescending(c => c.GetParameters().Length) // Prefer most params
            .FirstOrDefault();

        if (constructor == null)
        {
            throw new InvalidOperationException($"No public constructor found for {implementationType.Name}.");
        }

        var parameters = constructor.GetParameters()
            .Select(p => GetService(p.ParameterType))
            .ToArray();

        var instance = constructor.Invoke(parameters);
        _services[serviceType] = instance;

        return instance;
    }
}

//----------
public IEnumerable<TSource> DistinctBy<TSource, TKey>(this IEnumerable<TSource> source, Func<TSource, TKey> selector)
{
	if(source == null)
		throw new ArgumentNullException("source is missing");
	if(selector == null)
		throw new ArgumentNullException("selector is missing");
	
	HashSet<TKey> set = new HashSet<TKey>();
	
	foreach(var item in source)
	{
		if(set.Add(selector(item))
			yield item;
	}
}

var list = new List<Person>{
	new Person{
		Id =1,
		Name ="dd"
	},
	new Person{
		Id =2,
		Name ="dd"
	}
}

var filtered = list.DistinctBy(p => p.Name);//return only first Person

public IEnumerable<TSource> Except<TSource>(this IEnumerable<TSource> first, IEnumerable<TSource> second, IEqualityComparer<Tsource> comparer = null)
{
	if(first == null || second == nuint)
		throw ArgumentNullException("missing input");
	
	var set = new HashSet<Tsource>(second, comparer);
	foreach(var item in first)
	{
		if(!set.Contains(item))
			yield item;
	}
}


that, given an array A of N integers, returns the smallest positive integer (greater than 0) that does not occur in A.

For example, given A = [1, 3, 6, 4, 1, 2], the function should return 5.

Given A = [1, 2, 3], the function should return 4.

Given A = [−1, −3], the function should return 1.

Write an efficient algorithm for the following assumptions:

N is an integer within the range [1..100,000];
each element of array A is an integer within the range [−1,000,000..1,000,000].

using System;
using System.Collections.Generic;
// you can also use other imports, for example:
// using System.Collections.Generic;

// you can write to stdout for debugging purposes, e.g.
// Console.WriteLine("this is a debug message");

class Solution {
    public int solution(int[] A) {

        if(A.Length == 1)
            return Math.Abs(A[0]) + 1;

        var setA = new HashSet<int>(A);
        
        //find max pos element
        var maxPos =-1000000;

        for(int i=1 ; i< setA.Count; i++)
        {
            if(setA[i] > maxPos)
                maxPos = set[i];
        }

        //itterate over array
        for(int i =1; i<setA.Count; i++ )
        {
            if(setA[i] - setA[i -1] > 1 )
                return setA[i] + 1;
        }


        return setA[setA.Count -1] +1;
    }
}
using System;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;

public class ServiceProvider
{
    private static readonly Dictionary<Type, object> _services = new();
    private static readonly Dictionary<Type, Type> _registrations = new();

    public void AddService<IService, Service>() where Service : IService
    {
        var interfaceType = typeof(IService);
        var implementationType = typeof(Service);

        if (_registrations.ContainsKey(interfaceType))
        {
            throw new InvalidOperationException($"Service {interfaceType.Name} is already registered.");
        }

        _registrations[interfaceType] = implementationType;
    }

    public static IService GetService<IService>()
    {
        return (IService)GetService(typeof(IService));
    }

    private static object GetService(Type serviceType)
    {
        // Return existing instance if already created
        if (_services.TryGetValue(serviceType, out var existingInstance))
        {
            return existingInstance;
        }

        // Check if the service was registered
        if (!_registrations.TryGetValue(serviceType, out var implementationType))
        {
            throw new InvalidOperationException($"Service {serviceType.Name} is not registered.");
        }

        // Get constructor and resolve dependencies
        var constructor = implementationType
            .GetConstructors()
            .OrderByDescending(c => c.GetParameters().Length) // Prefer most params
            .FirstOrDefault();

        if (constructor == null)
        {
            throw new InvalidOperationException($"No public constructor found for {implementationType.Name}.");
        }

        var parameters = constructor.GetParameters()
            .Select(p => GetService(p.ParameterType))
            .ToArray();

        var instance = constructor.Invoke(parameters);
        _services[serviceType] = instance;

        return instance;
    }
}

//----------
public IEnumerable<TSource> DistinctBy<TSource, TKey>(this IEnumerable<TSource> source, Func<TSource, TKey> selector)
{
	if(source == null)
		throw new ArgumentNullException("source is missing");
	if(selector == null)
		throw new ArgumentNullException("selector is missing");
	
	HashSet<TKey> set = new HashSet<TKey>();
	
	foreach(var item in source)
	{
		if(set.Add(selector(item))
			yield item;
	}
}

var list = new List<Person>{
	new Person{
		Id =1,
		Name ="dd"
	},
	new Person{
		Id =2,
		Name ="dd"
	}
}

var filtered = list.DistinctBy(p => p.Name);//return only first Person

public IEnumerable<TSource> Except<TSource>(this IEnumerable<TSource> first, IEnumerable<TSource> second, IEqualityComparer<Tsource> comparer = null)
{
	if(first == null || second == nuint)
		throw ArgumentNullException("missing input");
	
	var set = new HashSet<Tsource>(second, comparer);
	foreach(var item in first)
	{
		if(!set.Contains(item))
			yield item;
	}
}


that, given an array A of N integers, returns the smallest positive integer (greater than 0) that does not occur in A.

For example, given A = [1, 3, 6, 4, 1, 2], the function should return 5.

Given A = [1, 2, 3], the function should return 4.

Given A = [−1, −3], the function should return 1.

Write an efficient algorithm for the following assumptions:

N is an integer within the range [1..100,000];
each element of array A is an integer within the range [−1,000,000..1,000,000].

using System;
using System.Collections.Generic;
// you can also use other imports, for example:
// using System.Collections.Generic;

// you can write to stdout for debugging purposes, e.g.
// Console.WriteLine("this is a debug message");

class Solution {
    public int solution(int[] A) {

        if(A.Length == 1)
            return Math.Abs(A[0]) + 1;

        var setA = new HashSet<int>(A);
        
        //find max pos element
        var maxPos =-1000000;

        for(int i=1 ; i< setA.Count; i++)
        {
            if(setA[i] > maxPos)
                maxPos = set[i];
        }

        //itterate over array
        for(int i =1; i<setA.Count; i++ )
        {
            if(setA[i] - setA[i -1] > 1 )
                return setA[i] + 1;
        }


        return setA[setA.Count -1] +1;
    }
}
using System;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;

public class ServiceProvider
{
    private static readonly Dictionary<Type, object> _services = new();
    private static readonly Dictionary<Type, Type> _registrations = new();

    public void AddService<IService, Service>() where Service : IService
    {
        var interfaceType = typeof(IService);
        var implementationType = typeof(Service);

        if (_registrations.ContainsKey(interfaceType))
        {
            throw new InvalidOperationException($"Service {interfaceType.Name} is already registered.");
        }

        _registrations[interfaceType] = implementationType;
    }

    public static IService GetService<IService>()
    {
        return (IService)GetService(typeof(IService));
    }

    private static object GetService(Type serviceType)
    {
        // Return existing instance if already created
        if (_services.TryGetValue(serviceType, out var existingInstance))
        {
            return existingInstance;
        }

        // Check if the service was registered
        if (!_registrations.TryGetValue(serviceType, out var implementationType))
        {
            throw new InvalidOperationException($"Service {serviceType.Name} is not registered.");
        }

        // Get constructor and resolve dependencies
        var constructor = implementationType
            .GetConstructors()
            .OrderByDescending(c => c.GetParameters().Length) // Prefer most params
            .FirstOrDefault();

        if (constructor == null)
        {
            throw new InvalidOperationException($"No public constructor found for {implementationType.Name}.");
        }

        var parameters = constructor.GetParameters()
            .Select(p => GetService(p.ParameterType))
            .ToArray();

        var instance = constructor.Invoke(parameters);
        _services[serviceType] = instance;

        return instance;
    }
}

//----------
public IEnumerable<TSource> DistinctBy<TSource, TKey>(this IEnumerable<TSource> source, Func<TSource, TKey> selector)
{
	if(source == null)
		throw new ArgumentNullException("source is missing");
	if(selector == null)
		throw new ArgumentNullException("selector is missing");
	
	HashSet<TKey> set = new HashSet<TKey>();
	
	foreach(var item in source)
	{
		if(set.Add(selector(item))
			yield item;
	}
}

var list = new List<Person>{
	new Person{
		Id =1,
		Name ="dd"
	},
	new Person{
		Id =2,
		Name ="dd"
	}
}

var filtered = list.DistinctBy(p => p.Name);//return only first Person

public IEnumerable<TSource> Except<TSource>(this IEnumerable<TSource> first, IEnumerable<TSource> second, IEqualityComparer<Tsource> comparer = null)
{
	if(first == null || second == nuint)
		throw ArgumentNullException("missing input");
	
	var set = new HashSet<Tsource>(second, comparer);
	foreach(var item in first)
	{
		if(!set.Contains(item))
			yield item;
	}
}


that, given an array A of N integers, returns the smallest positive integer (greater than 0) that does not occur in A.

For example, given A = [1, 3, 6, 4, 1, 2], the function should return 5.

Given A = [1, 2, 3], the function should return 4.

Given A = [−1, −3], the function should return 1.

Write an efficient algorithm for the following assumptions:

N is an integer within the range [1..100,000];
each element of array A is an integer within the range [−1,000,000..1,000,000].

using System;
using System.Collections.Generic;
// you can also use other imports, for example:
// using System.Collections.Generic;

// you can write to stdout for debugging purposes, e.g.
// Console.WriteLine("this is a debug message");

class Solution {
    public int solution(int[] A) {

        if(A.Length == 1)
            return Math.Abs(A[0]) + 1;

        var setA = new HashSet<int>(A);
        
        //find max pos element
        var maxPos =-1000000;

        for(int i=1 ; i< setA.Count; i++)
        {
            if(setA[i] > maxPos)
                maxPos = set[i];
        }

        //itterate over array
        for(int i =1; i<setA.Count; i++ )
        {
            if(setA[i] - setA[i -1] > 1 )
                return setA[i] + 1;
        }


        return setA[setA.Count -1] +1;
    }
}
